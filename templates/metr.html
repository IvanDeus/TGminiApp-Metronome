<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
 <meta name="viewport" content="width=device-width, initial-scale=1.0">
 <title>Metronome</title>
  <link rel="stylesheet" href="static/css/styles.css">
<script src="https://telegram.org/js/telegram-web-app.js"></script>
</head>
<body>
<div id="profile-pic" style="background-image: url('{{ photo_url }}');"></div>
<div class="credits" id="profile-name">[ ivan deus ]</div>

<div class="container">
  <div class="volume-control">
   <div class="volume-level" id="volume-level"></div>
</div>

<div class="controls">
<button class="control-start" id="playmetr">Start Metronome</button>
</div>

<div class="controls">
<button class="control-btn" id="tempo-down">Slower</button>

<div class="status" id="bpm-display">BPM: ---</div>

<button class="control-btn" id="tempo-up">Faster</button>
    </div>
</div>

<script>
    const audioContext = new (window.AudioContext || window.webkitAudioContext)();
    let currentBPM = 90;
    let isPlaying = false;
    let metronomeIntervalId = null; // Variable to store the interval ID
    let userId = null; // Variable to store the user ID

    function playClick() {
        const now = audioContext.currentTime;
        const osc = audioContext.createOscillator();
        const gainNode = audioContext.createGain();

        osc.type = 'square';
        osc.frequency.value = 800;
        gainNode.gain.setValueAtTime(0, now);
        gainNode.gain.linearRampToValueAtTime(0.1, now + 0.001);
        gainNode.gain.exponentialRampToValueAtTime(0.001, now + 0.02);

        osc.connect(gainNode);
        gainNode.connect(audioContext.destination);
        osc.start(now);
        osc.stop(now + 0.02);
    }

    function startMetronome() {
        // Clear any existing interval to prevent multiple metronomes playing
        if (metronomeIntervalId) {
            clearInterval(metronomeIntervalId);
        }
        const interval = 60000 / currentBPM;
        playClick(); // Play the first click immediately
        metronomeIntervalId = setInterval(() => {
            if (isPlaying) playClick();
        }, interval);
    }

    function stopMetronome() {
        if (metronomeIntervalId) {
            clearInterval(metronomeIntervalId);
            metronomeIntervalId = null; // Reset the interval ID
        }
    }

    function updateBPMDisplay() {
        const display = document.getElementById('bpm-display');
        if (display) {
            const paddedBPM = currentBPM.toString().padStart(3, '0');
            display.textContent = `BPM: ${paddedBPM}`;
        }
    }

    // Function to send user preferences to the server
    function sendUserPrefs() {
        if (userId !== null) { // Only send if userId is available
            const formData = new URLSearchParams();
            formData.append('user_id', userId);
            formData.append('bpm', currentBPM);

            // Use navigator.sendBeacon for reliable data transmission on page unload
            // or a synchronous XMLHttpRequest if sendBeacon is not supported (less ideal)
            if (navigator.sendBeacon) {
                navigator.sendBeacon('update_user_prefs', formData);
            } else {
                // Fallback for older browsers: synchronous XHR (can block page unload)
                const xhr = new XMLHttpRequest();
                xhr.open('POST', '/update_user_prefs', false); // 'false' makes it synchronous
                xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');
                xhr.send(formData);
            }
        }
    }

// --- TELEGRAM INIT FUNCTION ---
if (window.Telegram && Telegram.WebApp) {
    const initData = Telegram.WebApp.initData;

    fetch('init_telegram', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/x-www-form-urlencoded'
        },
        body: `initData=${encodeURIComponent(initData)}`
    })
    .then(response => {
        if (!response.ok) throw new Error("Network response was not ok");
        return response.json();
    })
    .then(data => {
        currentBPM = data.bpm || 90;
        userId = data.user_id; // Store the user_id from the initial data
        updateBPMDisplay();

        const profilePic = document.getElementById('profile-pic');
        if (profilePic) {
            profilePic.style.backgroundImage = `url('${data.photo_url}')`;
        }

        const profileNameElement = document.getElementById("profile-name");
        if (profileNameElement) {
           profileNameElement.innerText = `[ ${data.first_name} ]`;
        }

        setupButtonHandlers();
    })
    .catch(error => {
        console.error('Init failed:', error);
        showErrorMessage("This app only works inside Telegram");
    });
}

function setupButtonHandlers() {
    document.getElementById('tempo-up').onclick = () => {
        if (currentBPM < 320) {
            currentBPM += 4;
            updateBPMDisplay();
            // If playing, restart the metronome with the new BPM
            if (isPlaying) {
                startMetronome();
            }
        }
    };

    document.getElementById('tempo-down').onclick = () => {
        if (currentBPM > 24) {
            currentBPM -= 4;
            updateBPMDisplay();
            // If playing, restart the metronome with the new BPM
            if (isPlaying) {
                startMetronome();
            }
        }
    };

    // --- Metronome Play/Stop Button Handler ---
    const playMetrButton = document.getElementById('playmetr');
    if (playMetrButton) {
        playMetrButton.onclick = () => {
            if (isPlaying) {
                // Currently playing, so stop the metronome
                stopMetronome();
                playMetrButton.textContent = 'Start Metronome';
                isPlaying = false;
            } else {
                // Not playing, so start the metronome
                isPlaying = true;
                startMetronome();
                playMetrButton.textContent = 'Stop Metronome';
            }
        };
    }
}

function showErrorMessage(message) {
    document.body.innerHTML = `<div class="telegram-error">${message}</div>`;
}

// --- Save preferences on window close ---
window.addEventListener('beforeunload', sendUserPrefs);

// Disable context menu
 document.addEventListener('contextmenu', function (e) {
        e.preventDefault();
    }, false);
</script>
</body>
</html>